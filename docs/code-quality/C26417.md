---
title: C26417 | Documentos de Microsoft
ms.custom: ''
ms.date: 11/15/2017
ms.technology:
- vs-ide-code-analysis
ms.topic: conceptual
f1_keywords:
- C26417
helpviewer_keywords:
- C26417
ms.assetid: 0e09fcc6-f9eb-4404-b51e-5815705c6afb
author: mikeblome
ms.author: mblome
manager: douge
ms.workload:
- multiple
ms.openlocfilehash: 7c0e84ae9dd4d4860e9ab1a0dc65c737d7e95d3e
ms.sourcegitcommit: 6a9d5bd75e50947659fd6c837111a6a547884e2a
ms.translationtype: MT
ms.contentlocale: es-ES
ms.lasthandoff: 04/16/2018
---
# <a name="c26417-nolvaluerefsharedptr"></a>C26417 NO_LVALUE_REF_SHARED_PTR
"Parámetro de puntero compartido se pasa por referencia y no restablecer o vuelve a asignar. Usar T * o T & en su lugar. "

**Directrices de C++ centrales**:   
R.35: Toman una shared_ptr<widget>& parámetro expresar que una función puede volver a colocar el puntero compartido

Pasar punteros compartidos por referencia puede ser útil en escenarios donde el código de destinatario actualiza el destino del objeto de puntero inteligente y su llamador espera ver dicha actualización. Usar una referencia solamente para reducir los costos de pasar un puntero compartido está en peligro. Si el código de destinatario sólo tiene acceso a objetos de destino y nunca administra su duración, es más seguro pasar el puntero sin formato o una referencia, en lugar de exponer los detalles de administración de recursos.

## <a name="remarks"></a>Comentarios
-  Esta comprobación reconoce std::shared_pointer y tipos definidos por el usuario que están probables que se comportan como punteros compartidos. Para los punteros compartidos definidos por el usuario se esperan que las siguientes características:
-  sobrecarga de desreferenciación o de acceso a miembros de operadores (públicos y no se han eliminado);
-  constructor de copias o el operador de asignación de copia (público y no se han eliminado);
-  destructor público que no se eliminan ni su valor predeterminado. Destructores vacíos todavía se cuentan como definido por el usuario.
-  La acción de restablecimiento o la reasignación se interpreta de una forma más genérica:
-  cualquier llamada a un método no sea constante en un puntero compartido potencialmente puede restablecer el puntero;
-  cualquier llamada a una función que acepta una referencia a un puntero compartido no sea constante potencialmente puede restablecer o volver a asignar ese puntero.

## <a name="example"></a>Ejemplo 
complicación innecesarios de la interfaz

```cpp
bool unregister(std::shared_ptr<event> &e) // C26417, also C26415 SMART_PTR_NOT_NEEDED
{
    return e && events_.erase(e->id());
}

void renew(std::shared_ptr<event> &e)
{
    if (unregister(e))
        e = std::make_shared<event>(e->id());
    // ...
}
```

## <a name="example"></a>Ejemplo 
complicación innecesarios de la interfaz - simplificado

```cpp
bool unregister(const event *e)
{
    return e && events_.erase(e->id());
}

void renew(std::shared_ptr<event> &e)
{
    if (unregister(e.get()))
        e = std::make_shared<event>(e->id());
    // ...
}
```

